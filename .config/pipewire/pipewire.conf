context.properties = {
    link.max-buffers                       = 16
    #mem.warn-mlock                        = false
    #mem.allow-mlock                       = true
    #mem.mlock-all                         = false
    #clock.power-of-two-quantum            = true
    #log.level                             = 2
    #cpu.zero.denormals                    = false

    #loop.rt-prio = -1            # -1 = use module-rt prio, 0 disable rt
    #loop.class = data.rt
    #thread.affinity = [ 0 1 ]    # optional array of CPUs
    #context.num-data-loops = 1   # -1 = num-cpus, 0 = no data loops
    #
    #context.data-loops = [
        #    {   loop.rt-prio = -1
            #        loop.class = [ data.rt audio.rt ]
            #        #library.name.system = support/libspa-support
            #        thread.name = data-loop.0
            #        #thread.affinity = [ 0 1 ]    # optional array of CPUs
            #    }
            #]

            core.daemon = true              # listening for socket connections
            core.name   = pipewire-0        # core name and socket name

            ## Properties for the DSP configuration.
            default.clock.rate          = 48000
            default.clock.allowed-rates = [ 48000 ]
            default.clock.quantum       = 1024
            default.clock.min-quantum   = 32
            default.clock.max-quantum   = 2048
            default.clock.quantum-limit = 8192
            default.clock.quantum-floor = 4
            default.video.width         = 640
            default.video.height        = 480
            default.video.rate.num      = 25
            default.video.rate.denom    = 1

            settings.check-quantum      = false
            settings.check-rate         = false
}

context.properties.rules = [
    {   matches = [ { cpu.vm.name = !null } ]
        actions = {
            update-props = {
                # These overrides are only applied when running in a vm.
                default.clock.min-quantum = 1024
            }
        }
    }
]

context.spa-libs = {
    audio.convert.* = audioconvert/libspa-audioconvert
    avb.*           = avb/libspa-avb
    api.alsa.*      = alsa/libspa-alsa
    api.v4l2.*      = v4l2/libspa-v4l2
    api.libcamera.* = libcamera/libspa-libcamera
    api.bluez5.*    = bluez5/libspa-bluez5
    api.vulkan.*    = vulkan/libspa-vulkan
    api.jack.*      = jack/libspa-jack
    support.*       = support/libspa-support
    video.convert.* = videoconvert/libspa-videoconvert
}

context.modules = [
    { name = libpipewire-module-rt
        args = {
            nice.level    = -11
            rt.prio       = 88
        }
        flags = [ ifexists nofail ]
        condition = [ { module.rt = !false } ]
    }

    { name = libpipewire-module-protocol-native
        args = {
        }
    }

    { name = libpipewire-module-profiler
        args = {
            profile.interval.ms = 0
        }
        condition = [ { module.profiler = !false } ]
    }

    { name = libpipewire-module-metadata
        condition = [ { module.metadata = !false } ]
    }

    { name = libpipewire-module-spa-device-factory
        condition = [ { module.spa-device-factory = !false } ]
    }

    { name = libpipewire-module-spa-node-factory
        condition = [ { module.spa-node-factory = !false } ]
    }

    { name = libpipewire-module-client-node
        condition = [ { module.client-node = !false } ]
    }

    { name = libpipewire-module-client-device
        condition = [ { module.client-device = !false } ]
    }

    { name = libpipewire-module-portal
        flags = [ ifexists nofail ]
        condition = [ { module.portal = !false } ]
    }

    { name = libpipewire-module-access
        args = {
        }
        condition = [ { module.access = !false } ]
    }

    { name = libpipewire-module-adapter
        condition = [ { module.adapter = !false } ]
    }

    { name = libpipewire-module-link-factory
        args = {
        }
        condition = [ { module.link-factory = !false } ]
    }

    { name = libpipewire-module-session-manager
        condition = [ { module.session-manager = !false } ]
    }

    { name = libpipewire-module-x11-bell
        args = {
        }
        flags = [ ifexists nofail ]
        condition = [ { module.x11.bell = !false } ]
    }

    { name = libpipewire-module-jackdbus-detect
        args = {
            source.props = {
            }
            sink.props = {
            }
        }
        flags = [ ifexists nofail ]
        condition = [ { module.jackdbus-detect = !false } ]
    }

    { name = libpipewire-module-filter-chain
        flags = [ nofail ]
        args = {
            node.description = "Virtual Surround Sink"
            media.name       = "Virtual Surround Sink"
            filter.graph = {
                nodes = [
                    { type = builtin label = copy name = copyFL  }
                    { type = builtin label = copy name = copyFR  }
                    { type = builtin label = copy name = copyFC  }
                    { type = builtin label = copy name = copyRL  }
                    { type = builtin label = copy name = copyRR  }
                    { type = builtin label = copy name = copySL  }
                    { type = builtin label = copy name = copySR  }
                    { type = builtin label = copy name = copyLFE }

                    { type = builtin label = convolver name = convFL_L config = { filename = "/home/sten/pipewire/atmos.wav" channel =  0 } }
                    { type = builtin label = convolver name = convFL_R config = { filename = "/home/sten/pipewire/atmos.wav" channel =  1 } }
                    { type = builtin label = convolver name = convSL_L config = { filename = "/home/sten/pipewire/atmos.wav" channel =  2 } }
                    { type = builtin label = convolver name = convSL_R config = { filename = "/home/sten/pipewire/atmos.wav" channel =  3 } }
                    { type = builtin label = convolver name = convRL_L config = { filename = "/home/sten/pipewire/atmos.wav" channel =  4 } }
                    { type = builtin label = convolver name = convRL_R config = { filename = "/home/sten/pipewire/atmos.wav" channel =  5 } }
                    { type = builtin label = convolver name = convFC_L config = { filename = "/home/sten/pipewire/atmos.wav" channel =  6 } }
                    { type = builtin label = convolver name = convFR_R config = { filename = "/home/sten/pipewire/atmos.wav" channel =  7 } }
                    { type = builtin label = convolver name = convFR_L config = { filename = "/home/sten/pipewire/atmos.wav" channel =  8 } }
                    { type = builtin label = convolver name = convSR_R config = { filename = "/home/sten/pipewire/atmos.wav" channel =  9 } }
                    { type = builtin label = convolver name = convSR_L config = { filename = "/home/sten/pipewire/atmos.wav" channel = 10 } }
                    { type = builtin label = convolver name = convRR_R config = { filename = "/home/sten/pipewire/atmos.wav" channel = 11 } }
                    { type = builtin label = convolver name = convRR_L config = { filename = "/home/sten/pipewire/atmos.wav" channel = 12 } }
                    { type = builtin label = convolver name = convFC_R config = { filename = "/home/sten/pipewire/atmos.wav" channel = 13 } }
                    { type = builtin label = convolver name = convLFE_L config = { filename = "/home/sten/pipewire/atmos.wav" channel =  6 } }
                    { type = builtin label = convolver name = convLFE_R config = { filename = "/home/sten/pipewire/atmos.wav" channel = 13 } }

                    # stereo output
                    { type = builtin label = mixer name = mixL }
                    { type = builtin label = mixer name = mixR }
                ]
                links = [
                    # input
                    { output = "copyFL:Out"  input="convFL_L:In"  }
                    { output = "copyFL:Out"  input="convFL_R:In"  }
                    { output = "copySL:Out"  input="convSL_L:In"  }
                    { output = "copySL:Out"  input="convSL_R:In"  }
                    { output = "copyRL:Out"  input="convRL_L:In"  }
                    { output = "copyRL:Out"  input="convRL_R:In"  }
                    { output = "copyFC:Out"  input="convFC_L:In"  }
                    { output = "copyFR:Out"  input="convFR_R:In"  }
                    { output = "copyFR:Out"  input="convFR_L:In"  }
                    { output = "copySR:Out"  input="convSR_R:In"  }
                    { output = "copySR:Out"  input="convSR_L:In"  }
                    { output = "copyRR:Out"  input="convRR_R:In"  }
                    { output = "copyRR:Out"  input="convRR_L:In"  }
                    { output = "copyFC:Out"  input="convFC_R:In"  }
                    { output = "copyLFE:Out" input="convLFE_L:In" }
                    { output = "copyLFE:Out" input="convLFE_R:In" }

                    # output
                    { output = "convFL_L:Out"  input="mixL:In 1" }
                    { output = "convFL_R:Out"  input="mixR:In 1" }
                    { output = "convSL_L:Out"  input="mixL:In 2" }
                    { output = "convSL_R:Out"  input="mixR:In 2" }
                    { output = "convRL_L:Out"  input="mixL:In 3" }
                    { output = "convRL_R:Out"  input="mixR:In 3" }
                    { output = "convFC_L:Out"  input="mixL:In 4" }
                    { output = "convFC_R:Out"  input="mixR:In 4" }
                    { output = "convFR_R:Out"  input="mixR:In 5" }
                    { output = "convFR_L:Out"  input="mixL:In 5" }
                    { output = "convSR_R:Out"  input="mixR:In 6" }
                    { output = "convSR_L:Out"  input="mixL:In 6" }
                    { output = "convRR_R:Out"  input="mixR:In 7" }
                    { output = "convRR_L:Out"  input="mixL:In 7" }
                    { output = "convLFE_R:Out" input="mixR:In 8" }
                    { output = "convLFE_L:Out" input="mixL:In 8" }
                ]
                inputs  = [ "copyFL:In" "copyFR:In" "copyFC:In" "copyLFE:In" "copyRL:In" "copyRR:In", "copySL:In", "copySR:In" ]
                outputs = [ "mixL:Out" "mixR:Out" ]
            }
            capture.props = {
                node.name      = "effect_input.virtual-surround-7.1-hesuvi"
                media.class    = Audio/Sink
                audio.channels = 8
                audio.position = [ FL FR FC LFE RL RR SL SR ]
            }
            playback.props = {
                node.name      = "effect_output.virtual-surround-7.1-hesuvi"
                node.passive   = true
                audio.channels = 2
                audio.position = [ FL FR ]
            }
        }
    }
]

context.objects = [
    #{ factory = <factory-name>
        #    ( args  = { <key> = <value> ... } )
        #    ( flags = [ ( nofail ) ] )
        #    ( condition = [ { <key> = <value> ... } ... ] )
        #}
        #
        # Creates an object from a PipeWire factory with the given parameters.
        # If nofail is given, errors are ignored (and no object is created).
        # If condition is given, the object is created only when the context properties
        # all match the match rules.
        #
        #{ factory = spa-node-factory   args = { factory.name = videotestsrc node.name = videotestsrc node.description = videotestsrc node.param.Props = { patternType = 1 } } }
        #{ factory = spa-device-factory args = { factory.name = api.jack.device foo=bar } flags = [ nofail ] }
        #{ factory = spa-device-factory args = { factory.name = api.alsa.enum.udev } }
        #{ factory = spa-node-factory   args = { factory.name = api.alsa.seq.bridge node.name = Internal-MIDI-Bridge } }
        #{ factory = adapter            args = { factory.name = audiotestsrc node.name = my-test node.description = audiotestsrc node.param.Props = { live = false }} }
        #{ factory = spa-node-factory   args = { factory.name = api.vulkan.compute.source node.name = my-compute-source } }

        # A default dummy driver. This handles nodes marked with the "node.always-process"
        # property when no other driver is currently active. JACK clients need this.
        { factory = spa-node-factory
            args = {
                factory.name    = support.node.driver
                node.name       = Dummy-Driver
                node.group      = pipewire.dummy
                node.sync-group  = sync.dummy
                priority.driver = 200000
                #clock.id       = monotonic # realtime | tai | monotonic-raw | boottime
                #clock.name     = "clock.system.monotonic"
            }
            condition = [ { factory.dummy-driver = !false } ]
        }
        { factory = spa-node-factory
            args = {
                factory.name    = support.node.driver
                node.name       = Freewheel-Driver
                priority.driver = 190000
                node.group      = pipewire.freewheel
                node.sync-group  = sync.dummy
                node.freewheel  = true
                #freewheel.wait = 10
            }
            condition = [ { factory.freewheel-driver = !false } ]
        }

        # This creates a new Source node. It will have input ports
        # that you can link, to provide audio for this source.
        #{ factory = adapter
            #    args = {
                #        factory.name     = support.null-audio-sink
                #        node.name        = "my-mic"
                #        node.description = "Microphone"
                #        media.class      = "Audio/Source/Virtual"
                #        audio.position   = "FL,FR"
                #        monitor.passthrough = true
                #    }
                #}

                # This creates a single PCM source device for the given
                # alsa device path hw:0. You can change source to sink
                # to make a sink in the same way.
                #{ factory = adapter
                    #    args = {
                        #        factory.name           = api.alsa.pcm.source
                        #        node.name              = "alsa-source"
                        #        node.description       = "PCM Source"
                        #        media.class            = "Audio/Source"
                        #        api.alsa.path          = "hw:0"
                        #        api.alsa.period-size   = 1024
                        #        api.alsa.headroom      = 0
                        #        api.alsa.disable-mmap  = false
                        #        api.alsa.disable-batch = false
                        #        audio.format           = "S16LE"
                        #        audio.rate             = 48000
                        #        audio.channels         = 2
                        #        audio.position         = "FL,FR"
                        #    }
                        #}

                        # Use the metadata factory to create metadata and some default values.
                        #{ factory = metadata
                            #    args = {
                                #        metadata.name = my-metadata
                                #        metadata.values = [
                                    #            { key = default.audio.sink   value = { name = somesink } }
                                    #            { key = default.audio.source value = { name = somesource } }
                                    #        ]
                                    #    }
                                    #}
]

context.exec = [
    #{   path = <program-name>
        #    ( args = "<arguments>" | [ <arg1> <arg2> ... ] )
        #    ( condition = [ { <key> = <value> ... } ... ] )
        #}
        #
        # Execute the given program with arguments.
        # If condition is given, the program is executed only when the context
        # properties all match the match rules.
        #
        # You can optionally start the session manager here,
        # but it is better to start it as a systemd service.
        # Run the session manager with -h for options.
        #
        #{ path = "/usr/bin/pipewire-media-session" args = ""
            #  condition = [ { exec.session-manager = !false } ] }
            #
            # You can optionally start the pulseaudio-server here as well
            # but it is better to start it as a systemd service.
            # It can be interesting to start another daemon here that listens
            # on another address with the -a option (eg. -a tcp:4713).
            #
            #{ path = "/usr/bin/pipewire" args = [ "-c" "pipewire-pulse.conf" ]
                #  condition = [ { exec.pipewire-pulse = !false } ] }
]
